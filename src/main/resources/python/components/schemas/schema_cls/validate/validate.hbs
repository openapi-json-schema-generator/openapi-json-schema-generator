{{#if types}}
    {{#gt types.size 1}}
        {{#each types}}
            {{#eq this "object"}}
@typing.overload
@classmethod
def validate(
    {{> components/schemas/schema_cls/validate/_validate_args }}
                {{#if ../mapOutputJsonPathPiece}}
) -> {{../mapOutputJsonPathPiece.camelCase}}: ...
                {{else}}
) -> schemas.immutabledict[str, schemas.OUTPUT_BASE_TYPES]: ...
                {{/if}}
            {{else}}
                {{#eq this "boolean"}}
{{> components/schemas/schema_cls/validate/_validate_bool_overload includeNonEnum=true enumInfo=../enumInfo }}
                {{else}}
                    {{#eq this "null"}}
@typing.overload
@classmethod
def validate(
    {{> components/schemas/schema_cls/validate/_validate_args }}
) -> None: ...
                    {{else}}
                        {{#eq this "string"}}
{{> components/schemas/schema_cls/validate/_validate_str_overload includeNonEnum=true enumInfo=../enumInfo }}
                        {{else}}
                            {{#eq this "number"}}
@typing.overload
@classmethod
def validate(
    {{> components/schemas/schema_cls/validate/_validate_args }}
) -> typing.Union[int, float]: ...
                            {{else}}
                                {{#eq this "integer"}}
{{> components/schemas/schema_cls/validate/_validate_int_overload includeNonEnum=true enumInfo=../enumInfo }}
                                {{else}}
                                    {{#eq this "array"}}
@typing.overload
@classmethod
def validate(
    {{> components/schemas/schema_cls/validate/_validate_args }}
) -> {{#if ../arrayOutputJsonPathPiece}}{{../arrayOutputJsonPathPiece.camelCase}}{{else}}typing.Tuple[schemas.OUTPUT_BASE_TYPES, ...]{{/if}}: ...
                                    {{else}}
                                        {{#eq this "object"}}
@typing.overload
@classmethod
def validate(
    {{> components/schemas/schema_cls/validate/_validate_args }}
) -> {{#if ../mapOutputJsonPathPiece}}{{../mapOutputJsonPathPiece.camelCase}}{{else}}schemas.immutabledict[str, schemas.OUTPUT_BASE_TYPES]{{/if}}: ...
                                        {{/eq}}
                                    {{/eq}}
                                {{/eq}}
                            {{/eq}}
                        {{/eq}}
                    {{/eq}}
                {{/eq}}
            {{/eq}}
        {{/each}}
    {{else}}
        {{! only one type }}
{{> components/schemas/schema_cls/validate/_validate_str_overload includeNonEnum=false }}
{{> components/schemas/schema_cls/validate/_validate_bool_overload includeNonEnum=false }}
{{> components/schemas/schema_cls/validate/_validate_int_overload includeNonEnum=false }}
        {{! end of enum overloads }}
    {{/gt}}
@classmethod
def validate(
    {{#eq types.size 1}}
        {{#if enumInfo}}
            {{#eq type "integer"}}
    cls,
    arg,
    configuration: typing.Optional[schema_configuration.SchemaConfiguration] = None
            {{else}}
                {{#eq type "boolean"}}
    cls,
    arg,
    configuration: typing.Optional[schema_configuration.SchemaConfiguration] = None
                {{else}}
                    {{#eq type "string"}}
    cls,
    arg,
    configuration: typing.Optional[schema_configuration.SchemaConfiguration] = None
                    {{else}}
        {{#each types}}
    {{> components/schemas/schema_cls/validate/_validate_args }}
        {{/each}}
                    {{/eq}}
                {{/eq}}
            {{/eq}}
        {{else}}
        {{#each types}}
    {{> components/schemas/schema_cls/validate/_validate_args }}
        {{/each}}
        {{/if}}
    {{else}}
    cls,
    arg,
    configuration: typing.Optional[schema_configuration.SchemaConfiguration] = None
    {{/eq}}
    {{#eq types.size 1}}
        {{#each types}}
            {{#eq this "object"}}
                {{#if mapOutputJsonPathPiece}}
) -> {{mapOutputJsonPathPiece.camelCase}}:
                {{else}}
) -> schemas.immutabledict[str, schemas.OUTPUT_BASE_TYPES]:
                {{/if}}
            {{else}}
                {{#eq this "boolean"}}
) -> {{#if ../enumInfo}}typing.Literal[
        {{#each ../enumInfo.typeToValues.boolean}}
    {{#if value}}True{{else}}False{{/if}},
        {{/each}}
]{{else}}bool{{/if}}:
                {{else}}
                    {{#eq this "null"}}
) -> None:
                    {{else}}
                        {{#eq this "string"}}
) -> {{#if ../enumInfo}}typing.Literal[
        {{#each ../enumInfo.typeToValues.string}}
    "{{{value}}}",
        {{/each}}
]{{else}}str{{/if}}:
                        {{else}}
                            {{#eq this "number"}}
) -> typing.Union[int, float]:
                            {{else}}
                                {{#eq this "integer"}}
) -> {{#if ../enumInfo}}typing.Literal[
        {{#each ../enumInfo.typeToValues.integer}}
    {{value}},
        {{/each}}
]{{else}}int{{/if}}:
                                {{else}}
                                    {{#eq this "array"}}
                                        {{#if arrayOutputJsonPathPiece}}
) -> {{arrayOutputJsonPathPiece.camelCase}}:
                                        {{else}}
) -> typing.Tuple[schemas.OUTPUT_BASE_TYPES, ...]:
                                        {{/if}}
                                    {{/eq}}
                                {{/eq}}
                            {{/eq}}
                        {{/eq}}
                    {{/eq}}
                {{/eq}}
            {{/eq}}
        {{/each}}
    {{else}}
):
    {{/eq}}
    {{#if enumInfo}}
    validated_arg = super().validate_base(
        arg,
        configuration=configuration,
    )
        {{#eq types.size 1}}
            {{#eq type "string"}}
    return typing.cast(typing.Literal[
                {{#each enumInfo.typeToValues.string}}
            "{{{value}}}",
                {{/each}}
        ],
        validated_arg
    )
            {{else}}
                {{#eq type "integer"}}
    return typing.cast(typing.Literal[
                {{#each enumInfo.typeToValues.integer}}
            {{value}},
                {{/each}}
        ],
        validated_arg
    )
                {{else}}
                    {{#eq type "boolean"}}
    return typing.cast(typing.Literal[
                {{#each enumInfo.typeToValues.boolean}}
            {{#if value}}True{{else}}False{{/if}},
                {{/each}}
        ],
        validated_arg
    )
                    {{else}}
    return validated_arg
                    {{/eq}}
                {{/eq}}
            {{/eq}}
        {{else}}
            {{! no multiple enum types }}
    return validated_arg
        {{/eq}}
    {{else}}
        {{! no enumInfo }}
    return super().validate_base(
        arg,
        configuration=configuration,
    )
    {{/if}}
{{/if}}
