{{#if additionalProperties}}
    {{#if additionalProperties.isBooleanSchemaFalse}}
        {{! TypedDict use case }}
        {{#and requiredProperties optionalProperties}}
public class {{mapInputJsonPathPiece.camelCase}} {
    // requiredProperties, optionalProperties, NO additionalProperties
}
        {{else}}
            {{! empty mapping }}
public class {{mapInputJsonPathPiece.camelCase}} {
    // empty mapping
}
        {{/and}}
    {{else}}
        {{! addProps True/schema }}
        {{#if additionalProperties.isBooleanSchemaTrue }}
            {{! addProps True, does not matter what properties are because they are always covered by base types }}
public class {{mapInputJsonPathPiece.camelCase}} {
    // Map<String, Object> because additionalProperties == true
}
        {{else}}
            {{! addProps schema }}
            {{#and requiredProperties optionalProperties}}
public class {{mapInputJsonPathPiece.camelCase}} {
    // requiredProperties + optionalProperties + additionalProperties
}
            {{else}}
                {{! no requiredProperties or optionalProperties or just one of them }}
                {{#if requiredProperties}}
                    {{! requiredProperties + addProp }}
public class {{mapInputJsonPathPiece.camelCase}} {
    // requiredProperties + additionalProperties
}
                {{else}}
                    {{#if optionalProperties}}
                        {{! optionalProperties + addProp }}
public class {{mapInputJsonPathPiece.camelCase}} {
    // optionalProperties + additionalProperties
}
                    {{else}}
                        {{! only addProp }}
public class {{mapInputJsonPathPiece.camelCase}} {
    // Map<String, additionalProperties>
}
                    {{/if}}
                {{/if}}
            {{/and}}
        {{/if}}
    {{/if}}
{{else}}
    {{! addProps unset, does not matter what required and optional props are }}
public class {{mapInputJsonPathPiece.camelCase}} {
    // Map<String, Object> because addProps is unset
}
{{/if}}