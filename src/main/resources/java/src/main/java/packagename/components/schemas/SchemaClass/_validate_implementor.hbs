{{#if types}}
    {{#each types}}
        {{#eq this "null"}}

@Override
public Void castToAllowedTypes(Void arg, List<Object> pathToItem, Set<List<Object>> pathSet) {
    return castToAllowedVoidTypes(arg, pathToItem, pathSet);
}

@Override
public Void getNewInstance(Void arg, List<Object> pathToItem, PathToSchemasMap pathToSchemas) {
    return arg;
}

@Override
public Void validate(Void arg, SchemaConfiguration configuration) throws ValidationException {
    Set<List<Object>> pathSet = new HashSet<>();
    List<Object> pathToItem = List.of("args[0");
    Void castArg = castToAllowedTypes(arg, pathToItem, pathSet);
    SchemaConfiguration usedConfiguration = Objects.requireNonNullElseGet(configuration, () -> new SchemaConfiguration(JsonSchemaKeywordFlags.ofNone()));
    ValidationMetadata validationMetadata = new ValidationMetadata(pathToItem, usedConfiguration, new PathToSchemasMap(), new LinkedHashSet<>());
    PathToSchemasMap pathToSchemasMap = getPathToSchemas(this, castArg, validationMetadata, pathSet);
    return getNewInstance(castArg, validationMetadata.pathToItem(), pathToSchemasMap);
}
        {{/eq}}
        {{#eq this "object"}}

@Override
public FrozenMap<{{#with ../mapValueSchema}}{{> src/main/java/packagename/components/schemas/types/schema_cast_type sourceJsonPath=../jsonPath forceNull=true }}{{else}}Object{{/with}}> castToAllowedTypes(Map<String, {{#with ../mapValueSchema}}{{> src/main/java/packagename/components/schemas/types/schema_input_type sourceJsonPath=../jsonPath forceNull=true }}{{else}}Object{{/with}}> arg, List<Object> pathToItem, Set<List<Object>> pathSet) {
    pathSet.add(pathToItem);
    LinkedHashMap<String, {{#with ../mapValueSchema}}{{> src/main/java/packagename/components/schemas/types/schema_cast_type sourceJsonPath=../jsonPath forceNull=true }}{{else}}Object{{/with}}> argFixed = new LinkedHashMap<>();
    for (Map.Entry<String, {{#with ../mapValueSchema}}{{> src/main/java/packagename/components/schemas/types/schema_input_type sourceJsonPath=../jsonPath forceNull=true }}{{else}}Object{{/with}}> entry: arg.entrySet()) {
        String key = entry.getKey();
        {{#with ../mapValueSchema}}{{> src/main/java/packagename/components/schemas/types/schema_input_type sourceJsonPath=../jsonPath forceNull=true }}{{else}}Object{{/with}} val = entry.getValue();
        List<Object> newPathToItem = new ArrayList<>(pathToItem);
        newPathToItem.add(key);
        {{#with ../mapValueSchema}}{{> src/main/java/packagename/components/schemas/types/schema_cast_type sourceJsonPath=../jsonPath forceNull=true }}{{else}}Object{{/with}} fixedVal = ({{#with ../mapValueSchema}}{{> src/main/java/packagename/components/schemas/types/schema_cast_type sourceJsonPath=../jsonPath forceNull=true }}{{else}}Object{{/with}}) castToAllowedObjectTypes(val, newPathToItem, pathSet);
        argFixed.put(key, fixedVal);
    }
    return new FrozenMap<>(argFixed);
}

            {{#if ../mapOutputJsonPathPiece}}
public {{../mapOutputJsonPathPiece.camelCase}} getNewInstance(FrozenMap<{{#with ../mapValueSchema}}{{> src/main/java/packagename/components/schemas/types/schema_cast_type sourceJsonPath=../jsonPath forceNull=true }}{{else}}Object{{/with}}> arg, List<Object> pathToItem, PathToSchemasMap pathToSchemas) {
    LinkedHashMap<String, {{#with ../mapValueSchema}}{{> src/main/java/packagename/components/schemas/types/schema_output_type sourceJsonPath=../jsonPath forceNull=true }}{{else}}Object{{/with}}> properties = new LinkedHashMap<>();
    for(Map.Entry<String, {{#with ../mapValueSchema}}{{> src/main/java/packagename/components/schemas/types/schema_cast_type sourceJsonPath=../jsonPath forceNull=true }}{{else}}Object{{/with}}> entry: arg.entrySet()) {
        String propertyName = entry.getKey();
        List<Object> propertyPathToItem = new ArrayList<>(pathToItem);
        propertyPathToItem.add(propertyName);
        {{#with ../mapValueSchema}}{{> src/main/java/packagename/components/schemas/types/schema_cast_type sourceJsonPath=../jsonPath forceNull=true }}{{else}}Object{{/with}} value = entry.getValue();
        JsonSchema propertySchema = pathToSchemas.get(propertyPathToItem).entrySet().iterator().next().getKey();
        {{#with ../mapValueSchema}}{{> src/main/java/packagename/components/schemas/types/schema_output_type sourceJsonPath=../jsonPath forceNull=true }}{{else}}Object{{/with}} castValue = ({{#with ../mapValueSchema}}{{> src/main/java/packagename/components/schemas/types/schema_output_type sourceJsonPath=../jsonPath forceNull=true }}{{else}}Object{{/with}}) propertySchema.getNewInstance(value, propertyPathToItem, pathToSchemas);
        properties.put(propertyName, castValue);
    }
    FrozenMap<{{#with ../mapValueSchema}}{{> src/main/java/packagename/components/schemas/types/schema_output_type sourceJsonPath=../jsonPath forceNull=true }}{{else}}Object{{/with}}> castProperties = new FrozenMap<>(properties);
    return new {{mapOutputJsonPathPiece.camelCase}}(castProperties);
}
            {{else}}
@Override
public FrozenMap<{{#with ../mapValueSchema}}{{> src/main/java/packagename/components/schemas/types/schema_cast_type sourceJsonPath=../jsonPath forceNull=true }}{{else}}Object{{/with}}> getNewInstance(FrozenMap<{{#with ../mapValueSchema}}{{> src/main/java/packagename/components/schemas/types/schema_cast_type sourceJsonPath=../jsonPath forceNull=true }}{{else}}Object{{/with}}> arg, List<Object> pathToItem, PathToSchemasMap pathToSchemas) {
    return arg;
}
            {{/if}}

@Override
public {{#if ../mapOutputJsonPathPiece}}{{../mapOutputJsonPathPiece.camelCase}}{{else}}FrozenMap<Object>{{/if}} validate(Map<String, {{#with ../mapValueSchema}}{{> src/main/java/packagename/components/schemas/types/schema_input_type sourceJsonPath=../jsonPath forceNull=true }}{{else}}Object{{/with}}> arg, SchemaConfiguration configuration) throws ValidationException, InvalidTypeException {
    Set<List<Object>> pathSet = new HashSet<>();
    List<Object> pathToItem = List.of("args[0");
    FrozenMap<{{#with ../mapValueSchema}}{{> src/main/java/packagename/components/schemas/types/schema_cast_type sourceJsonPath=../jsonPath forceNull=true }}{{else}}Object{{/with}}> castArg = castToAllowedTypes(arg, pathToItem, pathSet);
    SchemaConfiguration usedConfiguration = Objects.requireNonNullElseGet(configuration, () -> new SchemaConfiguration(JsonSchemaKeywordFlags.ofNone()));
    ValidationMetadata validationMetadata = new ValidationMetadata(pathToItem, usedConfiguration, new PathToSchemasMap(), new LinkedHashSet<>());
    PathToSchemasMap pathToSchemasMap = getPathToSchemas(this, castArg, validationMetadata, pathSet);
    return getNewInstance(castArg, validationMetadata.pathToItem(), pathToSchemasMap);
}

        {{/eq}}
        {{#eq this "array"}}

@Override
public FrozenList<{{#with ../items}}{{> src/main/java/packagename/components/schemas/types/schema_cast_type sourceJsonPath=../jsonPath forceNull=true }}{{else}}Object{{/with}}> castToAllowedTypes(List<{{#with ../items}}{{> src/main/java/packagename/components/schemas/types/schema_input_type sourceJsonPath=../jsonPath forceNull=true }}{{else}}Object{{/with}}> arg, List<Object> pathToItem, Set<List<Object>> pathSet) {
    pathSet.add(pathToItem);
    List<{{#with ../items}}{{> src/main/java/packagename/components/schemas/types/schema_cast_type sourceJsonPath=../jsonPath forceNull=true }}{{else}}Object{{/with}}> argFixed = new ArrayList<>();
    int i =0;
    for ({{#with ../items}}{{> src/main/java/packagename/components/schemas/types/schema_input_type sourceJsonPath=../jsonPath forceNull=true }}{{else}}Object{{/with}} item: arg) {
        List<Object> newPathToItem = new ArrayList<>(pathToItem);
        newPathToItem.add(i);
        {{#with ../items}}{{> src/main/java/packagename/components/schemas/types/schema_cast_type sourceJsonPath=../jsonPath forceNull=true }}{{else}}Object{{/with}} fixedVal = ({{#with items}}{{> src/main/java/packagename/components/schemas/types/schema_cast_type sourceJsonPath=../jsonPath forceNull=true }}{{/with}}) castToAllowedObjectTypes(item, newPathToItem, pathSet);
        argFixed.add(fixedVal);
        i += 1;
    }
    return new FrozenList<>(argFixed);
}

@Override
public {{#if ../arrayOutputJsonPathPiece}}{{../arrayOutputJsonPathPiece.camelCase}}{{else}}FrozenList<{{#with ../items}}{{> src/main/java/packagename/components/schemas/types/schema_output_type sourceJsonPath=../jsonPath forceNull=true }}{{else}}Object{{/with}}>{{/if}} getNewInstance(FrozenList<{{#with ../items}}{{> src/main/java/packagename/components/schemas/types/schema_cast_type sourceJsonPath=../jsonPath forceNull=true }}{{else}}Object{{/with}}> arg, List<Object> pathToItem, PathToSchemasMap pathToSchemas) {
            {{#if ../arrayOutputJsonPathPiece}}
    ArrayList<{{#with ../items}}{{> src/main/java/packagename/components/schemas/types/schema_output_type sourceJsonPath=../jsonPath forceNull=true }}{{/with}}> items = new ArrayList<>();
    int i = 0;
    for ({{#with items}}{{> src/main/java/packagename/components/schemas/types/schema_cast_type sourceJsonPath=../jsonPath forceNull=true }}{{/with}} item: arg) {
        List<Object> itemPathToItem = new ArrayList<>(pathToItem);
        itemPathToItem.add(i);
        JsonSchema itemSchema = pathToSchemas.get(itemPathToItem).entrySet().iterator().next().getKey();
        {{#with items}}{{> src/main/java/packagename/components/schemas/types/schema_output_type sourceJsonPath=../jsonPath forceNull=true }}{{/with}} castItem = ({{#with items}}{{> src/main/java/packagename/components/schemas/types/schema_output_type sourceJsonPath=../jsonPath forceNull=true }}{{/with}}) itemSchema.getNewInstance(item, itemPathToItem, pathToSchemas);
        items.add(castItem);
        i += 1;
    }
    FrozenList<{{#with items}}{{> src/main/java/packagename/components/schemas/types/schema_output_type sourceJsonPath=../jsonPath forceNull=true }}{{/with}}> newInstanceItems = new FrozenList<>(items);
    return new {{../arrayOutputJsonPathPiece.camelCase}}(newInstanceItems);
            {{else}}
    return arg;
            {{/if}}
}

@Override
public {{#if ../arrayOutputJsonPathPiece}}{{../arrayOutputJsonPathPiece.camelCase}}{{else}}FrozenList<{{#with ../items}}{{> src/main/java/packagename/components/schemas/types/schema_output_type sourceJsonPath=../jsonPath forceNull=true }}{{else}}Object{{/with}}>{{/if}} validate(List<{{#with ../items}}{{> src/main/java/packagename/components/schemas/types/schema_input_type sourceJsonPath=../jsonPath forceNull=true }}{{else}}Object{{/with}}> arg, SchemaConfiguration configuration) throws ValidationException {
    Set<List<Object>> pathSet = new HashSet<>();
    List<Object> pathToItem = List.of("args[0");
    FrozenList<{{#with ../items}}{{> src/main/java/packagename/components/schemas/types/schema_cast_type sourceJsonPath=../jsonPath forceNull=true }}{{else}}Object{{/with}}> castArg = castToAllowedTypes(arg, pathToItem, pathSet);
    SchemaConfiguration usedConfiguration = Objects.requireNonNullElseGet(configuration, () -> new SchemaConfiguration(JsonSchemaKeywordFlags.ofNone()));
    ValidationMetadata validationMetadata = new ValidationMetadata(pathToItem, usedConfiguration, new PathToSchemasMap(), new LinkedHashSet<>());
    PathToSchemasMap pathToSchemasMap = getPathToSchemas(this, castArg, validationMetadata, pathSet);
    return getNewInstance(castArg, validationMetadata.pathToItem(), pathToSchemasMap);
}
        {{/eq}}
        {{#eq this "string" }}
            {{#eq ../format "binary"}}
// FileIO,
// bytes,
            {{else}}

@Override
public String castToAllowedTypes(String arg, List<Object> pathToItem, Set<List<Object>> pathSet) {
    return castToAllowedStringTypes(arg, pathToItem, pathSet);
}

@Override
public String getNewInstance(String arg, List<Object> pathToItem, PathToSchemasMap pathToSchemas) {
    return arg;
}

@Override
public String validate(String arg, SchemaConfiguration configuration) throws ValidationException {
    Set<List<Object>> pathSet = new HashSet<>();
    List<Object> pathToItem = List.of("args[0");
    String castArg = castToAllowedTypes(arg, pathToItem, pathSet);
    SchemaConfiguration usedConfiguration = Objects.requireNonNullElseGet(configuration, () -> new SchemaConfiguration(JsonSchemaKeywordFlags.ofNone()));
    ValidationMetadata validationMetadata = new ValidationMetadata(pathToItem, usedConfiguration, new PathToSchemasMap(), new LinkedHashSet<>());
    PathToSchemasMap pathToSchemasMap = getPathToSchemas(this, castArg, validationMetadata, pathSet);
    return getNewInstance(castArg, validationMetadata.pathToItem(), pathToSchemasMap);
}
            {{/eq}}
        {{/eq}}
        {{#eq this "integer"}}

@Override
public Number castToAllowedTypes(Number arg, List<Object> pathToItem, Set<List<Object>> pathSet) {
    return castToAllowedNumberTypes(arg, pathToItem, pathSet);
}

@Override
public Number getNewInstance(Number arg, List<Object> pathToItem, PathToSchemasMap pathToSchemas) {
    return arg;
}

@Override
public Number validate(Number arg, SchemaConfiguration configuration) throws ValidationException {
    Set<List<Object>> pathSet = new HashSet<>();
    List<Object> pathToItem = List.of("args[0");
    Number castArg = castToAllowedTypes(arg, pathToItem, pathSet);
    SchemaConfiguration usedConfiguration = Objects.requireNonNullElseGet(configuration, () -> new SchemaConfiguration(JsonSchemaKeywordFlags.ofNone()));
    ValidationMetadata validationMetadata = new ValidationMetadata(pathToItem, usedConfiguration, new PathToSchemasMap(), new LinkedHashSet<>());
    PathToSchemasMap pathToSchemasMap = getPathToSchemas(this, castArg, validationMetadata, pathSet);
    return getNewInstance(castArg, validationMetadata.pathToItem(), pathToSchemasMap);
}

public int validate(int arg, SchemaConfiguration configuration) throws ValidationException {
    return (int) validate((Number) arg, configuration);
}

public float validate(float arg, SchemaConfiguration configuration) throws ValidationException {
    return (float) validate((Number) arg, configuration);
}
            {{#neq ../format "int32"}}

public long validate(long arg, SchemaConfiguration configuration) throws ValidationException {
    return (long) validate((Number) arg, configuration);
}

public double validate(double arg, SchemaConfiguration configuration) throws ValidationException {
    return (double) validate((Number) arg, configuration);
}
            {{/neq}}
        {{/eq}}
        {{#eq this "number"}}

@Override
public Number castToAllowedTypes(Number arg, List<Object> pathToItem, Set<List<Object>> pathSet) {
    return castToAllowedNumberTypes(arg, pathToItem, pathSet);
}

@Override
public Number getNewInstance(Number arg, List<Object> pathToItem, PathToSchemasMap pathToSchemas) {
    return arg;
}

@Override
public Number validate(Number arg, SchemaConfiguration configuration) throws ValidationException {
    Set<List<Object>> pathSet = new HashSet<>();
    List<Object> pathToItem = List.of("args[0");
    Number castArg = castToAllowedTypes(arg, pathToItem, pathSet);
    SchemaConfiguration usedConfiguration = Objects.requireNonNullElseGet(configuration, () -> new SchemaConfiguration(JsonSchemaKeywordFlags.ofNone()));
    ValidationMetadata validationMetadata = new ValidationMetadata(pathToItem, usedConfiguration, new PathToSchemasMap(), new LinkedHashSet<>());
    PathToSchemasMap pathToSchemasMap = getPathToSchemas(this, castArg, validationMetadata, pathSet);
    return getNewInstance(castArg, validationMetadata.pathToItem(), pathToSchemasMap);
}
            {{#eq ../format null}}
public int validate(int arg, SchemaConfiguration configuration) throws ValidationException {
    return (int) validate((Number) arg, configuration);
}

public long validate(long arg, SchemaConfiguration configuration) throws ValidationException {
    return (long) validate((Number) arg, configuration);
}

public float validate(float arg, SchemaConfiguration configuration) throws ValidationException {
    return (float) validate((Number) arg, configuration);
}

public double validate(double arg, SchemaConfiguration configuration) throws ValidationException {
    return (double) validate((Number) arg, configuration);
}
            {{else}}
                {{#eq ../format "int32"}}
public int validate(int arg, SchemaConfiguration configuration) throws ValidationException {
    return (int) validate((Number) arg, configuration);
}

public float validate(float arg, SchemaConfiguration configuration) throws ValidationException {
    return (float) validate((Number) arg, configuration);
}
                {{else}}
                    {{#eq ../format "int64"}}
public int validate(int arg, SchemaConfiguration configuration) throws ValidationException {
    return (int) validate((Number) arg, configuration);
}

public float validate(float arg, SchemaConfiguration configuration) throws ValidationException {
    return (float) validate((Number) arg, configuration);
}

public long validate(long arg, SchemaConfiguration configuration) throws ValidationException {
    return (long) validate((Number) arg, configuration);
}

public double validate(double arg, SchemaConfiguration configuration) throws ValidationException {
    return (double) validate((Number) arg, configuration);
}
                    {{else}}
                        {{#eq ../format "float"}}
public float validate(float arg, SchemaConfiguration configuration) throws ValidationException {
    return (float) validate((Number) arg, configuration);
}
                        {{else}}
                            {{#eq ../format "double"}}
public double validate(double arg, SchemaConfiguration configuration) throws ValidationException {
    return (double) validate((Number) arg, configuration);
}
                            {{/eq}}
                        {{/eq}}
                    {{/eq}}
                {{/eq}}
            {{/eq}}
        {{/eq}}
        {{#eq this "boolean"}}

@Override
public boolean castToAllowedTypes(boolean arg, List<Object> pathToItem, Set<List<Object>> pathSet) {
    return castToAllowedBooleanTypes(arg, pathToItem, pathSet);
}

@Override
public boolean getNewInstance(boolean arg, List<Object> pathToItem, PathToSchemasMap pathToSchemas) {
    return arg;
}

@Override
public boolean validate(boolean arg, SchemaConfiguration configuration) throws ValidationException {
    Set<List<Object>> pathSet = new HashSet<>();
    List<Object> pathToItem = List.of("args[0");
    boolean castArg = castToAllowedTypes(arg, pathToItem, pathSet);
    SchemaConfiguration usedConfiguration = Objects.requireNonNullElseGet(configuration, () -> new SchemaConfiguration(JsonSchemaKeywordFlags.ofNone()));
    ValidationMetadata validationMetadata = new ValidationMetadata(pathToItem, usedConfiguration, new PathToSchemasMap(), new LinkedHashSet<>());
    PathToSchemasMap pathToSchemasMap = getPathToSchemas(this, castArg, validationMetadata, pathSet);
    return getNewInstance(castArg, validationMetadata.pathToItem(), pathToSchemasMap);
}
        {{/eq}}
    {{/each}}
{{else}}
@Override
public Void castToAllowedTypes(Void arg, List<Object> pathToItem, Set<List<Object>> pathSet) {
    return castToAllowedVoidTypes(arg, pathToItem, pathSet);
}

@Override
public Void getNewInstance(Void arg, List<Object> pathToItem, PathToSchemasMap pathToSchemas) {
    return arg;
}

@Override
public Void validate(Void arg, SchemaConfiguration configuration) throws ValidationException, InvalidTypeException {
    Set<List<Object>> pathSet = new HashSet<>();
    List<Object> pathToItem = new ArrayList<>();
    pathToItem.add("args[0]");
    Void castArg = castToAllowedTypes(arg, pathToItem, pathSet);
    SchemaConfiguration usedConfiguration = Objects.requireNonNullElseGet(configuration, () -> new SchemaConfiguration(JsonSchemaKeywordFlags.ofNone()));
    PathToSchemasMap validatedPathToSchemas = new PathToSchemasMap();
    ValidationMetadata validationMetadata = new ValidationMetadata(pathToItem, usedConfiguration, validatedPathToSchemas, new LinkedHashSet<>());
    PathToSchemasMap pathToSchemasMap = getPathToSchemas(this, castArg, validationMetadata, pathSet);
    return getNewInstance(castArg, validationMetadata.pathToItem(), pathToSchemasMap);
}

@Override
public boolean castToAllowedTypes(boolean arg, List<Object> pathToItem, Set<List<Object>> pathSet) {
    return castToAllowedBooleanTypes(arg, pathToItem, pathSet);
}

@Override
public boolean getNewInstance(boolean arg, List<Object> pathToItem, PathToSchemasMap pathToSchemas) {
    return arg;
}

@Override
public boolean validate(boolean arg, SchemaConfiguration configuration) throws ValidationException, InvalidTypeException {
    Set<List<Object>> pathSet = new HashSet<>();
    List<Object> pathToItem = new ArrayList<>();
    pathToItem.add("args[0]");
    boolean castArg = castToAllowedTypes(arg, pathToItem, pathSet);
    SchemaConfiguration usedConfiguration = Objects.requireNonNullElseGet(configuration, () -> new SchemaConfiguration(JsonSchemaKeywordFlags.ofNone()));
    PathToSchemasMap validatedPathToSchemas = new PathToSchemasMap();
    ValidationMetadata validationMetadata = new ValidationMetadata(pathToItem, usedConfiguration, validatedPathToSchemas, new LinkedHashSet<>());
    PathToSchemasMap pathToSchemasMap = getPathToSchemas(this, castArg, validationMetadata, pathSet);
    return getNewInstance(castArg, validationMetadata.pathToItem(), pathToSchemasMap);
}

@Override
public Number castToAllowedTypes(Number arg, List<Object> pathToItem, Set<List<Object>> pathSet) {
    return castToAllowedNumberTypes(arg, pathToItem, pathSet);
}

@Override
public Number getNewInstance(Number arg, List<Object> pathToItem, PathToSchemasMap pathToSchemas) {
    return arg;
}

@Override
public Number validate(Number arg, SchemaConfiguration configuration) throws ValidationException, InvalidTypeException {
    Set<List<Object>> pathSet = new HashSet<>();
    List<Object> pathToItem = new ArrayList<>();
    pathToItem.add("args[0]");
    Number castArg = castToAllowedTypes(arg, pathToItem, pathSet);
    SchemaConfiguration usedConfiguration = Objects.requireNonNullElseGet(configuration, () -> new SchemaConfiguration(JsonSchemaKeywordFlags.ofNone()));
    PathToSchemasMap validatedPathToSchemas = new PathToSchemasMap();
    ValidationMetadata validationMetadata = new ValidationMetadata(pathToItem, usedConfiguration, validatedPathToSchemas, new LinkedHashSet<>());
    PathToSchemasMap pathToSchemasMap = getPathToSchemas(this, castArg, validationMetadata, pathSet);
    return getNewInstance(castArg, validationMetadata.pathToItem(), pathToSchemasMap);
}

public int validate(int arg, SchemaConfiguration configuration) {
    return (int) validate((Number) arg, configuration);
}

public long validate(long arg, SchemaConfiguration configuration) {
    return (long) validate((Number) arg, configuration);
}

public float validate(float arg, SchemaConfiguration configuration) {
    return (float) validate((Number) arg, configuration);
}

public double validate(double arg, SchemaConfiguration configuration) {
    return (double) validate((Number) arg, configuration);
}

@Override
public String castToAllowedTypes(String arg, List<Object> pathToItem, Set<List<Object>> pathSet) {
    return castToAllowedStringTypes(arg, pathToItem, pathSet);
}

@Override
public String getNewInstance(String arg, List<Object> pathToItem, PathToSchemasMap pathToSchemas) {
    return arg;
}

@Override
public String validate(String arg, SchemaConfiguration configuration) throws ValidationException, InvalidTypeException {
    Set<List<Object>> pathSet = new HashSet<>();
    List<Object> pathToItem = new ArrayList<>();
    pathToItem.add("args[0]");
    String castArg = castToAllowedTypes(arg, pathToItem, pathSet);
    SchemaConfiguration usedConfiguration = Objects.requireNonNullElseGet(configuration, () -> new SchemaConfiguration(JsonSchemaKeywordFlags.ofNone()));
    PathToSchemasMap validatedPathToSchemas = new PathToSchemasMap();
    ValidationMetadata validationMetadata = new ValidationMetadata(pathToItem, usedConfiguration, validatedPathToSchemas, new LinkedHashSet<>());
    PathToSchemasMap pathToSchemasMap = getPathToSchemas(this, castArg, validationMetadata, pathSet);
    return getNewInstance(castArg, validationMetadata.pathToItem(), pathToSchemasMap);
}

public String validate(LocalDate arg, SchemaConfiguration configuration) throws ValidationException {
    return validate(arg.toString(), configuration);
}

public String validate(ZonedDateTime arg, SchemaConfiguration configuration) throws ValidationException {
    return validate(arg.toString(), configuration);
}

public String validate(UUID arg, SchemaConfiguration configuration) throws ValidationException {
    return validate(arg.toString(), configuration);
}

@Override
public FrozenList<Object> castToAllowedTypes(List<Object> arg, List<Object> pathToItem, Set<List<Object>> pathSet) {
    return castToAllowedListTypes(arg, pathToItem, pathSet);
}

@Override
public FrozenList<Object> getNewInstance(FrozenList<Object> arg, List<Object> pathToItem, PathToSchemasMap pathToSchemas) {
    return arg;
}

@Override
public FrozenList<Object> validate(List<Object> arg, SchemaConfiguration configuration) throws ValidationException, InvalidTypeException {
    Set<List<Object>> pathSet = new HashSet<>();
    List<Object> pathToItem = new ArrayList<>();
    pathToItem.add("args[0]");
    FrozenList<Object> castArg = castToAllowedTypes(arg, pathToItem, pathSet);
    SchemaConfiguration usedConfiguration = Objects.requireNonNullElseGet(configuration, () -> new SchemaConfiguration(JsonSchemaKeywordFlags.ofNone()));
    PathToSchemasMap validatedPathToSchemas = new PathToSchemasMap();
    ValidationMetadata validationMetadata = new ValidationMetadata(pathToItem, usedConfiguration, validatedPathToSchemas, new LinkedHashSet<>());
    PathToSchemasMap pathToSchemasMap = getPathToSchemas(this, castArg, validationMetadata, pathSet);
    return getNewInstance(castArg, validationMetadata.pathToItem(), pathToSchemasMap);
}

@Override
public FrozenMap<{{#with mapValueSchema}}{{> src/main/java/packagename/components/schemas/types/schema_cast_type sourceJsonPath=../jsonPath forceNull=true }}{{else}}Object{{/with}}> castToAllowedTypes(Map<String, {{#with mapValueSchema}}{{> src/main/java/packagename/components/schemas/types/schema_input_type sourceJsonPath=../jsonPath forceNull=true }}{{else}}Object{{/with}}> arg, List<Object> pathToItem, Set<List<Object>> pathSet) {
    {{#if mapValueSchema}}
    pathSet.add(pathToItem);
    LinkedHashMap<String, {{#with mapValueSchema}}{{> src/main/java/packagename/components/schemas/types/schema_cast_type sourceJsonPath=../jsonPath forceNull=true }}{{else}}Object{{/with}}> argFixed = new LinkedHashMap<>();
    for (Map.Entry<String, {{#with mapValueSchema}}{{> src/main/java/packagename/components/schemas/types/schema_input_type sourceJsonPath=../jsonPath forceNull=true }}{{else}}Object{{/with}}> entry: arg.entrySet()) {
        String key = entry.getKey();
        {{#with mapValueSchema}}{{> src/main/java/packagename/components/schemas/types/schema_input_type sourceJsonPath=../jsonPath forceNull=true }}{{else}}Object{{/with}} val = entry.getValue();
        List<Object> newPathToItem = new ArrayList<>(pathToItem);
        newPathToItem.add(key);
        {{#with mapValueSchema}}{{> src/main/java/packagename/components/schemas/types/schema_cast_type sourceJsonPath=../jsonPath forceNull=true }}{{else}}Object{{/with}} fixedVal = ({{#with mapValueSchema}}{{> src/main/java/packagename/components/schemas/types/schema_cast_type sourceJsonPath=../jsonPath forceNull=true }}{{else}}Object{{/with}}) castToAllowedObjectTypes(val, newPathToItem, pathSet);
        argFixed.put(key, fixedVal);
    }
    return new FrozenMap<>(argFixed);
    {{else}}
    return castToAllowedMapTypes(arg, pathToItem, pathSet);
    {{/if}}
}

@Override
public {{#if mapOutputJsonPathPiece}}{{mapOutputJsonPathPiece.camelCase}}{{else}}FrozenMap<{{#with mapValueSchema}}{{> src/main/java/packagename/components/schemas/types/schema_output_type sourceJsonPath=../jsonPath forceNull=true }}{{else}}Object{{/with}}>{{/if}} getNewInstance(FrozenMap<{{#with mapValueSchema}}{{> src/main/java/packagename/components/schemas/types/schema_cast_type sourceJsonPath=../jsonPath forceNull=true }}{{else}}Object{{/with}}> arg, List<Object> pathToItem, PathToSchemasMap pathToSchemas) {
    {{#if mapOutputJsonPathPiece}}
    LinkedHashMap<String, {{#with mapValueSchema}}{{> src/main/java/packagename/components/schemas/types/schema_output_type sourceJsonPath=../jsonPath forceNull=true }}{{else}}Object{{/with}}> properties = new LinkedHashMap<>();
    for(Map.Entry<String, {{#with mapValueSchema}}{{> src/main/java/packagename/components/schemas/types/schema_cast_type sourceJsonPath=../jsonPath forceNull=true }}{{else}}Object{{/with}}> entry: arg.entrySet()) {
        String propertyName = entry.getKey();
        List<Object> propertyPathToItem = new ArrayList<>(pathToItem);
        propertyPathToItem.add(propertyName);
        {{#with mapValueSchema}}{{> src/main/java/packagename/components/schemas/types/schema_cast_type sourceJsonPath=../jsonPath forceNull=true }}{{else}}Object{{/with}} value = entry.getValue();
        JsonSchema propertySchema = pathToSchemas.get(propertyPathToItem).entrySet().iterator().next().getKey();
        {{#with mapValueSchema}}{{> src/main/java/packagename/components/schemas/types/schema_output_type sourceJsonPath=../jsonPath forceNull=true }}{{else}}Object{{/with}} castValue = ({{#with mapValueSchema}}{{> src/main/java/packagename/components/schemas/types/schema_output_type sourceJsonPath=../jsonPath forceNull=true }}{{else}}Object{{/with}}) propertySchema.getNewInstance(value, propertyPathToItem, pathToSchemas);
        properties.put(propertyName, castValue);
    }
    FrozenMap<{{#with mapValueSchema}}{{> src/main/java/packagename/components/schemas/types/schema_output_type sourceJsonPath=../jsonPath forceNull=true }}{{else}}Object{{/with}}> castProperties = new FrozenMap<>(properties);
    return new {{mapOutputJsonPathPiece.camelCase}}(castProperties);
    {{else}}
    return arg;
    {{/if}}
}

@Override
public {{#if mapOutputJsonPathPiece}}{{mapOutputJsonPathPiece.camelCase}}{{else}}FrozenMap<{{#with mapValueSchema}}{{> src/main/java/packagename/components/schemas/types/schema_output_type sourceJsonPath=../jsonPath forceNull=true }}{{else}}Object{{/with}}>{{/if}} validate(Map<String, {{#with mapValueSchema}}{{> src/main/java/packagename/components/schemas/types/schema_input_type sourceJsonPath=../jsonPath forceNull=true }}{{else}}Object{{/with}}> arg, SchemaConfiguration configuration) throws ValidationException, InvalidTypeException {
    Set<List<Object>> pathSet = new HashSet<>();
    List<Object> pathToItem = new ArrayList<>();
    pathToItem.add("args[0]");
    FrozenMap<{{#with mapValueSchema}}{{> src/main/java/packagename/components/schemas/types/schema_cast_type sourceJsonPath=../jsonPath forceNull=true }}{{else}}Object{{/with}}> castArg = castToAllowedTypes(arg, pathToItem, pathSet);
    SchemaConfiguration usedConfiguration = Objects.requireNonNullElseGet(configuration, () -> new SchemaConfiguration(JsonSchemaKeywordFlags.ofNone()));
    PathToSchemasMap validatedPathToSchemas = new PathToSchemasMap();
    ValidationMetadata validationMetadata = new ValidationMetadata(pathToItem, usedConfiguration, validatedPathToSchemas, new LinkedHashSet<>());
    PathToSchemasMap pathToSchemasMap = getPathToSchemas(this, castArg, validationMetadata, pathSet);
    return getNewInstance(castArg, validationMetadata.pathToItem(), pathToSchemasMap);
}
{{/if}}