package {{{packageName}}}.schemas.validation;

import {{{packageName}}}.schemas.JsonSchema;

import java.lang.reflect.Field;
import java.util.HashMap;
import java.util.LinkedHashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

public abstract class SchemaValidator {
    static HashMap<String, KeywordValidator> keywordToValidator = new HashMap()\{{
        put("allOf", new FakeValidator());
        put("anyOf", new FakeValidator());
        put("const", new FakeValidator());
        put("contains", new FakeValidator());
        put("default", new FakeValidator());
        put("dependentRequired", new FakeValidator());
        put("dependentSchemas", new FakeValidator());
        put("discriminator", new FakeValidator());
        put("enumInfo", new FakeValidator());
        put("exclusiveMinimum", new FakeValidator());
        put("exclusiveMinimum", new FakeValidator());
        put("format", new FormatValidator());
        put("if_", new FakeValidator());
        put("then", new FakeValidator());
        put("else_", new FakeValidator());
        put("maxContains", new FakeValidator());
        put("maxItems", new FakeValidator());
        put("maxLength", new FakeValidator());
        put("maxProperties", new FakeValidator());
        put("maximum", new FakeValidator());
        put("minContains", new FakeValidator());
        put("minItems", new FakeValidator());
        put("minLength", new FakeValidator());
        put("minProperties", new FakeValidator());
        put("minimum", new FakeValidator());
        put("multipleOf", new FakeValidator());
        put("not", new FakeValidator());
        put("oneOf", new FakeValidator());
        put("pattern", new FakeValidator());
        put("patternProperties", new FakeValidator());
        put("prefixItems", new FakeValidator());
        put("required", new RequiredValidator());
        put("type", new TypeValidator());
        put("uniqueItems", new FakeValidator());
        put("items", new ItemsValidator());
        put("unevaluatedItems", new FakeValidator());
        put("properties", new PropertiesValidator());
        put("propertyNames", new FakeValidator());
        put("additionalProperties", new AdditionalPropertiesValidator());
        put("unevaluatedProperties", new FakeValidator());
    }};

    protected static PathToSchemasMap validate(
            Class<? extends SchemaValidator> schemaCls,
            Object arg,
            ValidationMetadata validationMetadata
    ) {
        HashMap<String, Object> fieldsToValues = new HashMap<>();
        LinkedHashSet<String> disabledKeywords = validationMetadata.configuration().disabledKeywordFlags().getKeywords();
        Class<? extends SchemaValidator> usedSchemaCls = schemaCls;
        if (schemaCls.getSuperclass() != JsonSchema.class) {
            // only ref with no adjacent properties supported at this time
            usedSchemaCls = (Class<? extends SchemaValidator>) schemaCls.getSuperclass();
        }
        Field[] fields = usedSchemaCls.getDeclaredFields();
        for (Field field : fields) {
            String fieldName = field.getName();
            if (fieldName.equals("keywordToValidator")) {
                continue;
            }
            if (fieldName.equals("this$0")) {
                continue;
            }
            if (disabledKeywords.contains(fieldName)) {
                continue;
            }
            try {
                Object value = field.get(null);
                fieldsToValues.put(fieldName, value);
            } catch (IllegalAccessException | IllegalArgumentException e) {
                throw new RuntimeException(e);
            }
        }
        Object extra = null;
        PathToSchemasMap pathToSchemas = new PathToSchemasMap();
        for (Map.Entry<String, Object> entry: fieldsToValues.entrySet()) {
            String jsonKeyword = entry.getKey();
            Object constraint = entry.getValue();
            if (jsonKeyword.equals("additionalProperties") && fieldsToValues.containsKey("properties")) {
                extra = fieldsToValues.get("properties");
            }
            KeywordValidator validatorClass = keywordToValidator.get(jsonKeyword);
            PathToSchemasMap otherPathToSchemas = validatorClass.validate(
                    schemaCls,
                    arg,
                    constraint,
                    validationMetadata,
                    extra
            );
            if (otherPathToSchemas == null) {
                continue;
            }
            pathToSchemas.update(otherPathToSchemas);
        }
        Class<?> baseClass;
        if (arg == null) {
            baseClass = Void.class;
        } else {
            baseClass = arg.getClass();
        }
        List<Object> pathToItem = validationMetadata.pathToItem();
        if (!pathToSchemas.containsKey(pathToItem)) {
            pathToSchemas.put(validationMetadata.pathToItem(), new LinkedHashMap<>());
        }
        pathToSchemas.get(pathToItem).put(baseClass, null);
        pathToSchemas.get(pathToItem).put(schemaCls, null);

        return pathToSchemas;
    }
}
