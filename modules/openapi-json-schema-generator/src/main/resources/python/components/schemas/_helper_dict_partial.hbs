{{#if requiredProperties}}
required: typing.FrozenSet[str] = frozenset({
{{#each requiredProperties}}
    "{{{@key.original}}}",
{{/each}}
})
{{/if}}
{{#if hasDiscriminatorWithNonEmptyMapping}}
    {{#with discriminator}}
discriminator: typing.Mapping[str, typing.Mapping[str, typing.Type[schemas.Schema]]] = dataclasses.field(
    default_factory=lambda: {
        '{{{propertyName.original}}}': {
        {{#each mappedModels}}
            '{{mappingName}}': {{{modelName}}},
        {{/each}}
        }
    }
)
    {{/with}}
{{/if}}
{{#if properties}}
properties: {{properties.jsonPathPiece.camelCase}} = dataclasses.field(default_factory=lambda: schemas.typed_dict_to_instance({{properties.jsonPathPiece.camelCase}})) # type: ignore
{{/if}}
{{#with additionalProperties}}
additional_properties: typing.Type[{{#if refInfo.refClass}}{{#if refInfo.refModule}}{{refInfo.refModule}}.{{/if}}{{refInfo.refClass}}{{else}}{{jsonPathPiece.camelCase}}{{/if}}] = dataclasses.field(default_factory=lambda: {{#if refInfo.refClass}}{{#if refInfo.refModule}}{{refInfo.refModule}}.{{/if}}{{refInfo.refClass}}{{else}}{{jsonPathPiece.camelCase}}{{/if}}) # type: ignore
{{/with}}
