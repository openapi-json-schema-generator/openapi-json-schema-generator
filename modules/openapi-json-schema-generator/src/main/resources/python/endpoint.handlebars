# coding: utf-8

{{>partial_header}}

from dataclasses import dataclass
import typing_extensions
import urllib3
{{#with operation}}
{{#or headerParams requestBody produces}}
from urllib3._collections import HTTPHeaderDict
{{/or}}
{{/with}}

from {{packageName}} import api_client, exceptions
{{> model_templates/imports_schema_types }}
{{> model_templates/imports }}
{{#with operation}}
{{#with requestBody}}
{{#if refModule}}
from {{packageName}}.components.request_bodies import {{refModule}} as request_body
{{/if}}
{{/with}}
{{#each responses}}
{{#with this}}
{{#if refModule}}
from {{packageName}}.components.responses import {{refModule}} as response_for_{{@key}}
{{/if}}
{{/with}}
{{/each}}
{{#each allParams}}
{{#if refModule}}
from {{packageName}}.components.parameters import {{refModule}}
{{/if}}
{{/each}}

{{#unless isStub}}
from .. import path
{{/unless}}
{{#each responses}}
{{#unless refModule}}
from . import response_for_{{@key}}
{{/unless}}
{{/each}}
{{#with requestBody}}
{{#unless refModule}}
from . import request_body
{{/unless}}
{{/with}}
{{#each allParams}}
{{#unless refModule}}
from . import {{name.getSnakeCaseName}}
{{/unless}}
{{/each}}

{{#or queryParams headerParams pathParams cookieParams}}
    {{#if queryParams}}
{{> endpoint_parameter_schema_and_def xParams=queryParams xParamsName="RequestQueryParameters" }}
    {{/if}}
    {{#if headerParams}}
{{> endpoint_parameter_schema_and_def xParams=headerParams xParamsName="RequestHeaderParameters" }}
    {{/if}}
    {{#if pathParams}}
{{> endpoint_parameter_schema_and_def xParams=pathParams xParamsName="RequestPathParameters" }}
    {{/if}}
    {{#if cookieParams}}
{{> endpoint_parameter_schema_and_def xParams=cookieParams xParamsName="RequestCookieParameters" }}
    {{/if}}
{{/or}}
{{#unless isStub}}
{{#each authMethods}}
{{#if @first}}

_auth = [
{{/if}}
    '{{name}}',
{{#if @last}}
]
{{/if}}
{{/each}}
{{#each servers}}
{{#if @first}}

_servers = (
{{/if}}
    {
        'url': "{{{url}}}",
        'description': "{{#unless description}}No description provided{{else}}{{{description}}}{{/unless}}",
        {{#each variables}}
        {{#if @first}}
        'variables': {
        {{/if}}
            '{{{name}}}': {
                'description': "{{#unless description}}No description provided{{else}}{{{description}}}{{/unless}}",
                'default_value': "{{{defaultValue}}}",
                {{#each enumValues}}
                {{#if @first}}
                'enum_values': [
                {{/if}}
                    "{{{.}}}"{{#unless @last}},{{/unless}}
                {{#if @last}}
                ]
                {{/if}}
                {{/each}}
                }{{#unless @last}},{{/unless}}
        {{#if @last}}
            }
        {{/if}}
        {{/each}}
    },
{{#if @last}}
)
{{/if}}
{{/each}}
{{/unless}}
{{#unless isStub}}


{{#if defaultResponse}}
{{#with defaultResponse}}
default_response = response_for_default.{{#if refClass}}{{refClass}}{{else}}{{name.getCamelCaseName}}{{/if}}
{{/with}}
{{/if}}
{{#if nonDefaultResponses}}
__StatusCodeToResponse = typing_extensions.TypedDict(
    '__StatusCodeToResponse',
    {
{{#each nonDefaultResponses}}
        '{{@key}}': response_for_{{@key}}.{{#if refClass}}{{refClass}}{{else}}{{name.getCamelCaseName}}{{/if}},
{{/each}}
    }
)
_status_code_to_response = __StatusCodeToResponse({
{{#each nonDefaultResponses}}
    '{{@key}}': response_for_{{@key}}.{{#if refClass}}{{refClass}}{{else}}{{name.getCamelCaseName}}{{/if}},
{{/each}}
})
{{/if}}
{{/unless}}
{{#each produces}}
{{#if @first}}
_all_accept_content_types = (
{{/if}}
    '{{{this.mediaType}}}',
{{#if @last}}
)
{{/if}}
{{/each}}


class BaseApi(api_client.Api):
{{#if requestBody}}
    {{#each getContentTypeToOperation}}
    {{> endpoint_args_baseapi_wrapper contentType=@key this=this}}

    {{/each}}
    {{> endpoint_args_baseapi_wrapper contentType="null" this=this}}

{{else}}
    @typing.overload
    def _{{operationId}}(
    {{> endpoint_args isOverload=true skipDeserialization="False" contentType="null"}}
{{/if}}

    @typing.overload
    def _{{operationId}}(
    {{> endpoint_args isOverload=true skipDeserialization="True" contentType="null"}}

    @typing.overload
    def _{{operationId}}(
    {{> endpoint_args isOverload=true skipDeserialization="null" contentType="null"}}

    def _{{operationId}}(
    {{> endpoint_args isOverload=false skipDeserialization="null" contentType="null"}}
        """
    {{#if summary}}
        {{summary}}
    {{/if}}
        :param skip_deserialization: If true then api_response.response will be set but
            api_response.body and api_response.headers will not be deserialized into schema
            class instances
        """
    {{#if queryParams}}
        self._verify_typed_dict_inputs(RequestQueryParameters.Params, query_params)
    {{/if}}
    {{#if headerParams}}
        self._verify_typed_dict_inputs(RequestHeaderParameters.Params, header_params)
    {{/if}}
    {{#if pathParams}}
        self._verify_typed_dict_inputs(RequestPathParameters.Params, path_params)
    {{/if}}
    {{#if cookieParams}}
        self._verify_typed_dict_inputs(RequestCookieParameters.Params, cookie_params)
    {{/if}}
        used_path = path
    {{#if pathParams}}

        _path_params = {}
        for parameter in RequestPathParameters.parameters:
            parameter_data = path_params.get(parameter.name, schemas.unset)
            if parameter_data is schemas.unset:
                continue
            serialized_data = parameter.serialize(parameter_data)
            _path_params.update(serialized_data)

        for k, v in _path_params.items():
            used_path = used_path.replace('{%s}' % k, v)
    {{/if}}
    {{#if queryParams}}

        prefix_separator_iterator = None
        for parameter in RequestQueryParameters.parameters:
            parameter_data = query_params.get(parameter.name, schemas.unset)
            if parameter_data is schemas.unset:
                continue
            if prefix_separator_iterator is None:
                prefix_separator_iterator = parameter.get_prefix_separator_iterator()
            serialized_data = parameter.serialize(parameter_data, prefix_separator_iterator)
            for serialized_value in serialized_data.values():
                used_path += serialized_value
    {{/if}}
    {{#or headerParams requestBody produces}}

        _headers = HTTPHeaderDict()
    {{else}}
    {{/or}}
    {{#if headerParams}}
        for parameter in RequestHeaderParameters.parameters:
            parameter_data = header_params.get(parameter.name, schemas.unset)
            if parameter_data is schemas.unset:
                continue
            serialized_data = parameter.serialize(parameter_data)
            _headers.extend(serialized_data)
    {{/if}}
        # TODO add cookie handling
    {{#if produces}}
        if accept_content_types:
            for accept_content_type in accept_content_types:
                _headers.add('Accept', accept_content_type)
    {{/if}}
    {{#with requestBody}}

    {{#if ref}}
        {{#if ref.getRef.required}}
        if body is schemas.unset:
            raise exceptions.ApiValueError(
                'The required body parameter has an invalid value of: unset. Set a valid value instead')
        {{/if}}
    {{else}}
        {{#if required}}
        if body is schemas.unset:
            raise exceptions.ApiValueError(
                'The required body parameter has an invalid value of: unset. Set a valid value instead')
        {{/if}}
    {{/if}}
        _fields = None
        _body = None
    {{#if ref}}
        {{#if ref.getRef.required}}
        {{> endpoint_body_serialization }}
        {{else}}
        if body is not schemas.unset:
            {{> endpoint_body_serialization }}
        {{/if}}
    {{else}}
        {{#if required}}
        {{> endpoint_body_serialization }}
        {{else}}
        if body is not schemas.unset:
            {{> endpoint_body_serialization }}
        {{/if}}
    {{/if}}
    {{/with}}
    {{#if servers}}

        host = self._get_host('{{operationId}}', _servers, host_index)
    {{/if}}

        response = self.api_client.call_api(
            resource_path=used_path,
            method='{{httpMethod}}'.upper(),
    {{#or headerParams requestBody produces}}
            headers=_headers,
    {{/or}}
    {{#if requestBody}}
            fields=_fields,
            body=_body,
    {{/if}}
    {{#if hasAuthMethods}}
            auth_settings=_auth,
    {{/if}}
    {{#if servers}}
            host=host,
    {{/if}}
            stream=stream,
            timeout=timeout,
        )

        if skip_deserialization:
            api_response = api_client.ApiResponseWithoutDeserialization(response=response)
        else:
{{#if nonDefaultResponses}}
            status = str(response.status)
            if status in _status_code_to_response:
                status: typing_extensions.Literal[
{{#each nonDefaultResponses}}
                    '{{@key}}',
{{/each}}
                ]
                api_response = _status_code_to_response[status].deserialize(response, self.api_client.configuration)
            else:
                {{#if defaultResponse}}
                api_response = default_response.deserialize(response, self.api_client.configuration)
                {{else}}
                api_response = api_client.ApiResponseWithoutDeserialization(response=response)
                {{/if}}
{{else}}
            {{#if defaultResponse}}
            api_response = default_response.deserialize(response, self.api_client.configuration)
            {{else}}
            api_response = api_client.ApiResponseWithoutDeserialization(response=response)
            {{/if}}
{{/if}}

        if not 200 <= response.status <= 299:
            raise exceptions.ApiException(
                status=response.status,
                reason=response.reason,
                api_response=api_response
            )

        return api_response


class {{operationIdCamelCase}}(BaseApi):
    # this class is used by api classes that refer to endpoints with operationId fn names

{{#if requestBody}}
    {{#each getContentTypeToOperation}}
    {{> endpoint_args_operationid_wrapper contentType=@key this=this}}

    {{/each}}
    {{> endpoint_args_operationid_wrapper contentType="null" this=this}}

{{else}}
    @typing.overload
    def {{operationId}}(
    {{> endpoint_args isOverload=true skipDeserialization="False" contentType="null"}}
{{/if}}

    @typing.overload
    def {{operationId}}(
    {{> endpoint_args isOverload=true skipDeserialization="True" contentType="null"}}

    @typing.overload
    def {{operationId}}(
    {{> endpoint_args isOverload=true skipDeserialization="null" contentType="null"}}

    def {{operationId}}(
    {{> endpoint_args isOverload=false skipDeserialization="null" contentType="null"}}
        return self._{{operationId}}(
            {{> endpoint_args_passed }}
        )


class ApiFor{{httpMethod}}(BaseApi):
    # this class is used by api classes that refer to endpoints by path and http method names

{{#if requestBody}}
    {{#each getContentTypeToOperation}}
    {{> endpoint_args_httpmethod_wrapper contentType=@key this=this}}

    {{/each}}
    {{> endpoint_args_httpmethod_wrapper contentType="null" this=this}}

{{else}}
    @typing.overload
    def {{httpMethod}}(
    {{> endpoint_args isOverload=true skipDeserialization="False" contentType="null"}}
{{/if}}

    @typing.overload
    def {{httpMethod}}(
    {{> endpoint_args isOverload=true skipDeserialization="True" contentType="null"}}

    @typing.overload
    def {{httpMethod}}(
    {{> endpoint_args isOverload=true skipDeserialization="null" contentType="null"}}

    def {{httpMethod}}(
    {{> endpoint_args isOverload=false skipDeserialization="null" contentType="null"}}
        return self._{{operationId}}(
            {{> endpoint_args_passed }}
        )


{{/with}}
