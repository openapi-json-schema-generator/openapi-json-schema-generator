# {{{projectName}}}
{{#if appDescriptionWithNewLines}}
{{{appDescriptionWithNewLines}}}
{{/if}}

This Python package is automatically generated by the [OpenAPI JSON Schema Generator](https://github.com/openapi-json-schema-tools/openapi-json-schema-generator) project:

- API version: {{appVersion}}
- Package version: {{packageVersion}}
{{#unless hideGenerationTimestamp}}
- Build date: {{generatedDate}}
{{/unless}}
- Build package: {{generatorClass}}
{{#if infoUrl}}
For more information, please visit [{{{infoUrl}}}]({{{infoUrl}}})
{{/if}}

## Requirements

Python {{generatorLanguageVersion}}

## Migration Guides
- [2.0.0 Migration Guide](migration_2_0_0.md)
- [Migration from Other Python Generators](migration_other_python_generators.md)


## Installation
### pip install

If the python package is hosted on a repository, you can install directly using:

```sh
pip install git+https://{{gitHost}}/{{{gitUserId}}}/{{{gitRepoId}}}.git
```
(you may need to run `pip` with root permission: `sudo pip install git+https://{{gitHost}}/{{{gitUserId}}}/{{{gitRepoId}}}.git`)

Then import the package:
```python
import {{{packageName}}}
```

### Setuptools

Install via [Setuptools](http://pypi.python.org/pypi/setuptools).

```sh
python -m pip install . --user
```
(or `python -m pip install .` to install the package for all users)

Then import the package:
```python
import {{{packageName}}}
```

## Usage Notes

### Validation, Immutability, and Data Type
This generator seeks to validate data nd return back an immutable instance containing the data
which subclasses all validated schema classes. This ensure that
- valid data cannot be mutated and become invalid to a set of schemas
  - the one exception is that files are not immutable, so schema instances storing/sending/receiving files are not immutable
- one can use isinstance to check if a instance or property is valid to a schema class
  - this means that expensive validation does not need to be run twice

To do that, some changes had to be made. Python bool and NoneType cannot be subclassed,
so to be able to meet the above design goals, I implemented BoolClass and NoneClass classes
to allow schemas to subclass them.

In python 0 == False and 1 == True. This is a problem for json schema which is language independent.
The [json schema test suite](https://github.com/json-schema-org/JSON-Schema-Test-Suite) has
[explicit tests that require that 0 != False and 1 != True](https://github.com/json-schema-org/JSON-Schema-Test-Suite/blob/main/tests/draft2020-12/type.json#L260-L267)
Using the above described BoolClass and NoneClasses allows those tests to pass.
- Another example of a package using it's own boolean class is [numpy's bool_](https://numpy.org/doc/stable/reference/arrays.scalars.html#numpy.bool_)

If you need to check is True/False/None, instead use instance.is_true_()/.is_false_()/.is_none_()

Here is the mapping from json schema types to python subclassed types:
| Json Schema Type | Python Base Class |
| ---------------- | ----------------- |
| object           | frozendict.frozendict |
| array            | tuple |
| string           | str |
| number           | decimal.Decimal |
| integer          | decimal.Decimal |
| boolean          | BoolClass |
| null             | NoneClass |
| AnyType (unset)  | typing.Union[frozendict.frozendict, tuple, str, decimal.Decimal, BoolClass, NoneClass] |

TODO add binary + file types and mention why

TODO add section on Schema_ storage and mention why

### Json Schema Type Object
Most component schemas (models) are probably of type object. Which is a map data structure.
Json schema allows string keys in this map, which means schema properties can have key names that are
invalid python variable names. Names like:
- "hi-there"
- "1variable"
- "@now"
- " "
To allow these use cases to work, frozendict.frozendict is used as the base class of type object schemas.
This means that one can use normal dict methods on instances of these classes.
- optional properties which were not set will not exist in the instance
- None is only allowed in as a variable if type: "null" was included or nullable: true was set
- type hints are written for accessing values by key literals like instance["hi-there"]
- and there is a method instance.get_item_["hi-there"] which returns an schemas.Unset value if the key was not set
- required properties with valid python names are accessible with instance.SomeRequiredProp
  which uses the exact key from the openapi document
  - preserving the original key names is required to properly validate a payload to multiple json schemas

### Json Schema Type + Format, Validated Dats Storage
N schemas can be validated on the same payload.
For example the string payload '2023-12-20' is validates to both of these schemas:
1. string only
```
- type: string
```
2. string and date format
```
- type: string
  format: date
```
Because of use cases like this, a datetime.date is allowed as an input to this schema, but the data
is stored as a string, with a date accessor, instance.as_date_
See te below accessors for string data:
- type string + format: See .as_date_, .as_datetime_, .as_decimal_, .as_uuid_

In json schema, type: number with no format validates both integers and floats.
To allow storage of both data type, decimal.Decimal is used to store type: number + type: integer data.
See te below accessors for number data:
- type number + format: See .as_float_, .as_int_


## Getting Started

Please follow the [installation procedure](#installation--usage) and then run the following:

{{> _helper_readme_common }}
